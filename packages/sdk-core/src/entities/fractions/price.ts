import JSBI from "jsbi";
import invariant from "tiny-invariant";
import { BigintIsh, Rounding } from "../../constants";
import { currencyEquals } from "../../utils";
import { Currency } from "../currency";
import CurrencyAmount from "./currencyAmount";
import Fraction from "./fraction";

export default class Price extends Fraction {
    public readonly baseCurrency: Currency; // input i.e. denominator
    public readonly quoteCurrency: Currency; // output i.e. numerator
    public readonly scalar: Fraction; // used to adjust the raw fraction w/r/t the decimals of the {base,quote}Token

    // denominator and numerator _must_ be raw, i.e. in the native representation
    public constructor(baseCurrency: Currency, quoteCurrency: Currency, denominator: BigintIsh, numerator: BigintIsh) {
        super(numerator, denominator);

        this.baseCurrency = baseCurrency;
        this.quoteCurrency = quoteCurrency;
        this.scalar = new Fraction(
            JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(baseCurrency.decimals)),
            JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(quoteCurrency.decimals)),
        );
    }

    public get raw(): Fraction {
        return new Fraction(this.numerator, this.denominator);
    }

    public get adjusted(): Fraction {
        return super.multiply(this.scalar);
    }

    public override invert(): Price {
        return new Price(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
    }

    public override multiply(other: Price): Price {
        invariant(currencyEquals(this.quoteCurrency, other.baseCurrency), "TOKEN");
        const fraction = super.multiply(other);
        return new Price(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
    }

    // quotes with floor division
    public quote(currencyAmount: CurrencyAmount): CurrencyAmount {
        invariant(currencyEquals(currencyAmount.currency, this.baseCurrency), "TOKEN");
        return new CurrencyAmount(this.quoteCurrency, super.multiply(currencyAmount.raw).quotient);
    }

    public override toSignificant(significantDigits: number = 6, format?: object, rounding?: Rounding): string {
        return this.adjusted.toSignificant(significantDigits, format, rounding);
    }

    public override toFixed(decimalPlaces: number = 4, format?: object, rounding?: Rounding): string {
        return this.adjusted.toFixed(decimalPlaces, format, rounding);
    }
}
